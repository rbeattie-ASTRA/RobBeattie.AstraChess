<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Astra eChessBoard</title>
  <link rel="stylesheet" href="style.css" />


<style>
/* Use locally installed 'Alpha' font with fallback */
body, .square, #helpModal {
  font-family: 'ChessAlpha', Arial, sans-serif;
}

/* Global styles */
body {
  background: #111;
  color: #eee;
  text-align: center;
  padding: 20px;
}

h1 {
  margin-bottom: 10px;
}

.board-wrapper {
  position: relative;
  display: inline-block;
}

#chessboard {
  display: grid;
  grid-template-columns: repeat(8, 75px);
  grid-template-rows: repeat(8, 75px);
  border: 2px solid #888;
}

.square {
  width: 75px;
  height: 75px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 70px;
  font-weight: normal;
  user-select: none;
}

.white {
  background-color: #f5f5f5;
  color: #000;
}

.black {
  background-color: #888;
  color: #000;
}

/* Safari-only tint for white-side pieces */
body.safari .piece.white-side {
  color: #add8e6 !important; /* lightblue */
}

.rank-labels {
  position: absolute;
  left: -30px;
  top: 0;
  display: grid;
  grid-template-rows: repeat(8, 75px);
  height: 600px;
  font-size: 14px;
  color: #aaa;
  align-items: center;
  text-align: center;
}

.file-labels {
  position: absolute;
  top: 600px;
  left: 0;
  display: grid;
  grid-template-columns: repeat(8, 75px);
  height: 20px;
  font-size: 14px;
  color: #aaa;
  text-align: center;
  line-height: 20px;
  padding-top: 5px;
}

.controls {
  margin-top: 20px;
}

.controls input[type="text"] {
  width: 300px;
  padding: 5px;
  margin-left: 10px;
}

#exportFEN {
  margin-top: 15px;
  padding: 8px 16px;
  background-color: #444;
  color: #eee;
  border: 1px solid #888;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

#exportFEN:hover {
  background-color: #666;
}

/* Modal styles */
#modalOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: none;
  z-index: 999;
}

#helpModal {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: #fff;
  padding: 20px;
  border-radius: 8px;
  max-width: 600px;
  width: 90%;
  display: none;
  z-index: 1000;
  color: #0077cc;
  text-align: left;
}

.closeBtn {
  position: absolute;
  top: 10px; right: 10px;
  background: none;
  border: none;
  font-size: 18px;
  cursor: pointer;
}

.controls {
  margin-top: 20px;
}

/* Make the two radio option labels stack vertically */
.controls label {
  display: block;
  margin-bottom: 8px;
}

.controls input[type="text"] {
  width: 300px;
  padding: 5px;
  margin-left: 10px;
}

</style>

</head>
<body>
  <h1>Astra eChessBoard</h1>
  <p style="margin-top: -5px; font-size: 14px; color: #888;">by Rob Beattie</p>

  <div class="board-wrapper">
    <div class="rank-labels">
      <div>8</div><div>7</div><div>6</div><div>5</div><div>4</div><div>3</div><div>2</div><div>1</div>
    </div>
    <div id="chessboard"></div>
    <div class="file-labels">
      <div>a</div><div>b</div><div>c</div><div>d</div><div>e</div><div>f</div><div>g</div><div>h</div>
    </div>
  </div>
  <div class="controls">
    <label><input type="radio" name="position" value="start" checked> Initial Board Position</label>
    <label><input type="radio" name="position" value="fen"> Input FEN Position</label>
    <input type="text" id="fenInput" placeholder="Enter FEN string here" />
    <button onclick="loadPosition()">Load Position</button>
  </div>

  <!-- Help Button -->
  <button id="openHelpBtn">♟️ Help</button>

  <!-- Modal Overlay -->
  <div id="modalOverlay"></div>

  <!-- Help Modal -->
  <div id="helpModal">
    <button class="closeBtn" onclick="closeHelp()">✖</button>
    <h2>♟️ How to Use Astra eChessBoard</h2>
    <ol>
  <li><strong>Choose a Starting Position</strong><br>Select “Start Position” for a standard chess setup, or “Custom FEN” to load any position using a FEN string.</li>
  <li><strong>Enter a FEN String (Optional)</strong><br>Paste a valid FEN string into the input box to load a custom board layout. Click “Load Position” to apply.</li>
  <li><strong>Drag and Drop Pieces</strong><br>Move pieces by dragging them from one square to another. Works best on desktop browsers.</li>
  <li><strong>Right-Click to Add Pieces</strong><br>Right-click any empty square to open the piece picker. Click a piece to place it on the board.</li>
  <li><strong>Export the Current Position</strong><br>Click “Export FEN” to copy the current board state to your clipboard. Share it or save it for later.</li>
  <li><strong>Play with a Friend</strong><br>Share the website link with someone to play asynchronously. You can both update the board and exchange FENs.</li>
  <li><strong>Remove Pieces</strong><br>Drag a piece off the board (outside the grid) to delete it. Useful for clearing mistakes or editing positions.</li>
  <li><strong>Use on iPad (with caveats)</strong><br>Fully functional when using mouse. Unicode rendering may vary — especially for white pawns. Best viewed on desktop.</li>
  <li><strong>Customising</strong><br>Astra eChessBoard is free for non-commercial use. Please do not modify without attribution, please quote "Astra eChessBoard by Rob Beattie".</li>
  <li><strong>Stay Version-Aware</strong><br>This is v6.2 — visually best in a Windows browser. Please provide feedback for other OS's / distros. Future versions might have playback capabilities. </li>
  <li><strong>Contact</strong><br>You can email me at rsbeattie@outlook.com put 'Astra eChessBoard' in subject field.</li>
  <li><strong>History</strong><br>Astra eChessBoard was created to support my friend Duncan during a challenging time — a way to stay mentally engaged, uplifted, and connected through Chess.</li>
</ol>
  </div>

  <!-- Scripts -->

  <script>
    const modal = document.getElementById('helpModal');
    const overlay = document.getElementById('modalOverlay');

    document.getElementById('openHelpBtn').onclick = () => {
      modal.style.display = 'block';
      overlay.style.display = 'block';
    };

    function closeHelp() {
      modal.style.display = 'none';
      overlay.style.display = 'none';
    }
 

const board = document.getElementById("chessboard");

// ...existing code...

// Unicode piece symbols (default)
const unicodePieceSymbols = {
  r: "♜", n: "♞", b: "♝", q: "♛", k: "♚", p: "♟",
  R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔", P: "♙"
};

// ASCII fallbacks for Safari
const asciiPieceSymbols = {
  r: "r", n: "n", b: "b", q: "q", k: "k", p: "p",
  R: "R", N: "N", B: "B", Q: "Q", K: "K", P: "P"
};

// Detect Safari (excludes Chrome/Android/Firefox iOS builds)
function isSafariBrowser() {
  const ua = navigator.userAgent || "";
  return /^((?!chrome|crios|fxios|android).)*safari/i.test(ua);
}
const isSafari = isSafariBrowser();
if (isSafari) document.body.classList.add('safari');

// Use ASCII on Safari, Unicode elsewhere (default)
const pieceSymbols = isSafari ? asciiPieceSymbols : unicodePieceSymbols;

let draggedFromSquare = null;

function createBoard() {
  board.innerHTML = "";
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const square = document.createElement("div");
      square.classList.add("square");
      const isWhite = (row + col) % 2 === 0;
      square.classList.add(isWhite ? "white" : "black");
      square.dataset.row = row;
      square.dataset.col = col;
      square.setAttribute("ondrop", "drop(event)");
      square.setAttribute("ondragover", "allowDrop(event)");
      board.appendChild(square);
    }
  }
}

function makePieceElement(symbol, side, originalKey) {
  const piece = document.createElement("div");
  piece.textContent = symbol;
  piece.setAttribute("draggable", "true");
  piece.classList.add("piece");
  piece.classList.add(side === 'white' ? 'white-side' : 'black-side');
  piece.dataset.side = side;
  if (originalKey) piece.dataset.key = originalKey; // store original piece key for FEN export
  piece.setAttribute("ondragstart", "drag(event)");
  // Safari inline fallback color (CSS body.safari .piece.white-side also applies)
  if (isSafari && side === 'white') piece.style.color = '#add8e6';
  return piece;
}

function loadFEN(fen) {
  createBoard();
  const rows = fen.split(" ")[0].split("/");
  rows.forEach((row, rIdx) => {
    let col = 0;
    for (let char of row) {
      if (isNaN(char)) {
        const square = board.querySelector(
          `.square[data-row="${rIdx}"][data-col="${col}"]`
        );
        if (square) {
          const side = char === char.toUpperCase() ? 'white' : 'black';
          const key = char; // original key (e.g. 'P' or 'p')
          const symbol = pieceSymbols[key] || "";
          const piece = makePieceElement(symbol, side, key);
          square.innerHTML = "";
          square.appendChild(piece);
        }
        col++;
      } else {
        col += parseInt(char);
      }
    }
  });
}

function loadPosition() {
  const selected = document.querySelector('input[name="position"]:checked').value;
  const fenInput = document.getElementById("fenInput").value.trim();
  if (selected === "start") {
    loadFEN("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
  } else if (fenInput) {
    loadFEN(fenInput);
  }
}

function allowDrop(ev) {
  ev.preventDefault();
}

function drag(ev) {
  const pieceEl = ev.target;
  draggedFromSquare = pieceEl.parentElement;
  ev.dataTransfer.setData("text", pieceEl.textContent);
  ev.dataTransfer.setData("class", pieceEl.className);
  ev.dataTransfer.setData("side", pieceEl.dataset.side || "");
  ev.dataTransfer.setData("key", pieceEl.dataset.key || "");
}

function drop(ev) {
  ev.preventDefault();
  const data = ev.dataTransfer.getData("text");
  const className = ev.dataTransfer.getData("class");
  const side = ev.dataTransfer.getData("side");
  const originalKey = ev.dataTransfer.getData("key"); // may be empty if created via picker

  let target = ev.target;
  if (!target.classList.contains("square")) {
    target = target.closest(".square");
  }

  if (target && draggedFromSquare) {
    draggedFromSquare.innerHTML = "";
    target.innerHTML = "";
    const piece = document.createElement("div");
    piece.textContent = data;
    piece.className = className;
    piece.setAttribute("draggable", "true");
    piece.setAttribute("ondragstart", "drag(event)");
    if (side) {
      piece.dataset.side = side;
      if (side === 'white') piece.classList.add('white-side');
      else piece.classList.add('black-side');
    }
    if (originalKey) piece.dataset.key = originalKey;
    // re-apply Safari tint if white and safari
    if (isSafari && piece.dataset.side === 'white') piece.style.color = '#add8e6';
    target.appendChild(piece);
    draggedFromSquare = null;
  }
}

// Utility: Copy to clipboard
function copyToClipboard(text) {
  const el = document.createElement("textarea");
  el.value = text;
  document.body.appendChild(el);
  el.select();
  document.execCommand("copy");
  document.body.removeChild(el);
  alert("Copied to clipboard!");
}

// Utility: Generate FEN from current board
function getCurrentFEN() {
  // Build mapping from displayed symbol back to piece key
  // Prefer dataset.key when available; otherwise look up by displayed text
  let fen = "";
  for (let row = 0; row < 8; row++) {
    let empty = 0;
    for (let col = 0; col < 8; col++) {
      const square = board.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
      const piece = square?.querySelector(".piece");
      if (piece) {
        if (empty > 0) {
          fen += empty;
          empty = 0;
        }
        // Prefer stored original key (P,p etc.)
        let key = piece.dataset.key;
        if (!key) {
          // fallback: find key by matching piece.textContent to pieceSymbols values
          key = Object.entries(pieceSymbols).find(([k, v]) => v === piece.textContent)?.[0] || "";
        }
        fen += key || "";
      } else {
        empty++;
      }
    }
    if (empty > 0) fen += empty;
    if (row < 7) fen += "/";
  }
  return fen + " w KQkq - 0 1";
}

// UI: Add export button
const exportBtn = document.createElement("button");
exportBtn.textContent = "Export FEN";
exportBtn.id = "exportFEN";
exportBtn.onclick = () => {
  const fen = getCurrentFEN();
  copyToClipboard(fen);
};
document.body.appendChild(exportBtn);

loadPosition();

document.addEventListener("dragend", (ev) => {
  const x = ev.clientX;
  const y = ev.clientY;
  const boardRect = board.getBoundingClientRect();
  const insideBoard =
    x >= boardRect.left &&
    x <= boardRect.right &&
    y >= boardRect.top &&
    y <= boardRect.bottom;

  if (!insideBoard && draggedFromSquare) {
    draggedFromSquare.innerHTML = ""; // Remove piece
    draggedFromSquare = null;
  }
});

const piecePicker = document.createElement("div");
piecePicker.id = "piecePicker";
piecePicker.style.position = "absolute";
piecePicker.style.background = "#222";
piecePicker.style.border = "1px solid #888";
piecePicker.style.padding = "5px";
piecePicker.style.zIndex = "1000";
piecePicker.style.flexDirection = "column";
piecePicker.style.gap = "4px";
piecePicker.style.display = "none"; // Hide AFTER layout styles
document.body.appendChild(piecePicker);

// Create two rows: one for white, one for black
const whiteRow = document.createElement("div");
whiteRow.style.display = "flex";
whiteRow.style.justifyContent = "center";
whiteRow.style.gap = "4px";

const blackRow = document.createElement("div");
blackRow.style.display = "flex";
blackRow.style.justifyContent = "center";
blackRow.style.gap = "4px";

const allPieces = Object.entries(pieceSymbols);
allPieces.forEach(([key, symbol]) => {
  const btn = document.createElement("button");
  btn.textContent = symbol;
  btn.style.margin = "2px";
  btn.style.fontSize = "24px";

  // determine side for button closure
  const side = key[0] === key[0].toUpperCase() ? 'white' : 'black';

  btn.onclick = () => {
    if (piecePicker.targetSquare) {
      const piece = makePieceElement(symbol, side, key);
      piecePicker.targetSquare.innerHTML = "";
      piecePicker.targetSquare.appendChild(piece);
    }
    piecePicker.style.display = "none";
  };

  // Sort into white or black row based on key
  if (side === 'white') {
    whiteRow.appendChild(btn); // White pieces
  } else {
    blackRow.appendChild(btn); // Black pieces
  }
});

piecePicker.appendChild(whiteRow);
piecePicker.appendChild(blackRow);
board.addEventListener("contextmenu", (ev) => {
  ev.preventDefault();
  const square = ev.target.closest(".square");
  if (square && square.children.length === 0) {
    piecePicker.style.left = `${ev.pageX}px`;
    piecePicker.style.top = `${ev.pageY}px`;
    piecePicker.style.display = "block";
    piecePicker.targetSquare = square;
  } else {
    piecePicker.style.display = "none";
  }
});

document.addEventListener("click", () => {
  piecePicker.style.display = "none";
});
 </script>

<script>
document.getElementById('openHelpBtn').addEventListener('click', function() {
  document.getElementById('helpModal').style.display = 'block';
  document.getElementById('modalOverlay').style.display = 'block';
});

function closeHelp() {
  document.getElementById('helpModal').style.display = 'none';
  document.getElementById('modalOverlay').style.display = 'none';
}
</script>


</body>
</html>